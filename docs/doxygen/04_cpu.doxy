/** @page riscv_core_page RISC-V Processor Core

  Basic tasks of Central Processor Unit (CPU) are:

\li Fetch and decode instructions
\li Supply operands for the Arithmetic and Logic unit (ALU), the Integer Multiply
and Divide block and for the Floating Pointing Unit (FPU) if enabled.
\li Load and Store data operands of the instructions

  River CPU implements five-stage pipeline with the possibility to \c Halt execution
at any time without neccessity of pipeline flushing. \c Halt signal itself can be
generated by User via Debug Support Unit (DSU) or by modules inside of pipeline.
This architecture allows to proccess several instructions in parallel and provides
functionality of the Debug Mode at any time.

  Moreover, processor River provides <b>non-invasive debugging</b> access that allows
to read/modify processors registers without halting the pipeline.

<center>
 <img src="../doxygen/pics/river_top.png" alt="Top Level"> 
 @latexonly {\includegraphics{../doxygen/pics/river_top.png}} @endlatexonly

<b>Figure 4-1. Functional diagram of the River CPU.</b>
</center>

  RISC-V Core \c River continues developing to support new instructions sets
and improve performance. The following table contains brief information
about already implemented features and features that are now in the development.

<center>
<table>
  <tr>
    <th>Function</th> <th>River, the latest ver.</th> <th>Description</th>
  </tr>
  <tr>
    <td>RISC-V User Level spec</td>  <td>2.2</td>   <td>See @link riscv.org. @endlink</td>
  </tr>
  <tr>
    <td>RISC-V Priviledged Level spec</td>  <td>1.10</td>   <td>See @link riscv.org. @endlink</td>
  </tr>
  <tr>
    <td>GCC version</td>  <td>7.2.2 or newer</td>   <td>Used as a default
       toolchain in the open-source repository</td>
  </tr>
  <tr>
    <td>GCC for Windows.</td>  <td>Yes</td>   <td>Cross-platform
        toolchain is available for a different OS</td>
  </tr>
  <tr>
    <td>C-extension</td>  <td>Yes</td>   <td>Compressed (16-bit)
        instructions set support</td>
  </tr>
  <tr>
    <td>D-extension</td>  <td>Yes</td>   <td>Double precision
       (64-bits) floating point instructions set</td>
  </tr>
  <tr>
    <td>F-extension</td>  <td>Partially</td>   <td>Single precision
       (32-bits) floating point instructions set not used in the current
        DSP algoritms. Full support will be added later.</td>
  </tr>
  <tr>
    <td>A-extension</td>  <td>Planned</td>   <td>Atomic instructions
        set support. Planned in release v.11.0</td>
  </tr>
  <tr>
    <td>Instruction Cache</td>  <td>Yes</td>   <td>Configurable
       IP. Default configurations: 4-ways, 16 KB</td>
  </tr>
  <tr>
    <td>Data Cache</td>  <td>Developing</td>   <td>Configurable
       IP. Default configurations: 4-ways, 16 KB. Planned in v10.0</td>
  </tr>
  <tr>
    <td>Brach Predictor</td>  <td>Yes</td>   <td>Improve CPI
     performance index on 15 %</td>
  </tr>
  <tr>
    <td>Stack Protection</td>  <td>Yes, not integrated</td>   <td>Generate
       exceptions on stack overflow or underflow events. Implements
       custom Control and Status Registers (CSR) in CPU. Planned in v9.0</td>
  </tr>
  <tr>
    <td>Watchdog</td>  <td>Planned</td>   <td>Generate
       exceptions on stachk overflow or underflow. Planned in v10.0</td>
  </tr>
</table>
<b>Table 4-1. RIVER CPU features list.</b>
</center>


 @section riverlib_generic_section Generic Configuration

  River CPU implementation shared as IP block writen on VHDL. All source files
should be placed in \c riverlib VHDL library before compilation. The following
main generic parameters are avaiable for the user configuration.

<center>
<table>
  <tr>
    <th>Name</th>    <th>Value</th>   <th>Description</th>
  </tr>
  <tr>
    <td>async_reset</td>
    <td>FALSE</td>
    <td><b>Reset Type</b>. Internal registers reset type:
       <ul>
         <li>FALSE: syncrhonous reset (FPGA)</li>
         <li>TRUE: asynchronous reset (ASIC)</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_VENDOR_ID</td>
    <td>X"000000F1"</td>
    <td><b>Vendor ID</b>. Hardcoded constant available for reading in
       standard CSR register described in RISC-V ISA</td>
  </tr>
  <tr>
    <td>CFG_IMPLEMENTATION_ID</td>
    <td>X"20190512"</td>
    <td><b>Implementation ID</b>. Hardcoded constant available for reading in
       standard CSR register described in RISC-V ISA.</td>
  </tr>
  <tr>
    <td>CFG_HW_FPU_ENABLE</td>
    <td>true</td>
    <td><b>Enable FPU</b>. Enable/disable FPU IP:
       <ul>
         <li>FALSE: Disable FPU</li>
         <li>TRUE: Enable FPU</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_SINGLEPORT_CACHE</td>
    <td>true</td>
    <td><b>Singleport Memory in Caches</b>. Specify memory blocks type
       used in caches implementation. Dual-Port memory can improve performance
       but requires bigger ASIC silicon usage.
       <ul>
         <li>FALSE: Use Dual-Port memory blocks for caches</li>
         <li>TRUE: Use Single-Port memory blocks for caches</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_IINDEX_WIDTH</td>
    <td>6</td>
    <td><b>Lines Per Way</b>. This value defines number of lines
       instantiated in each way for Instruction Cache:
       <ul>
         <li>1: Analog of Cache disabled</li>
         <li>6: 4 KB per Way. Total cache size 16 KB</li>
         <li>7: 8 KB per Way. Total cache size 32 KB</li>
         <li>8: 16 KB per Way. Total cache size 64 KB</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_DINDEX_WIDTH</td>
    <td>6</td>
    <td><b>Lines Per Way</b>. This value defines number of lines
       instantiated in each way for Data Cache:
       <ul>
         <li>1: Analog of Cache disabled</li>
         <li>6: 4 KB per Way. Total cache size 16 KB</li>
         <li>7: 8 KB per Way. Total cache size 32 KB</li>
         <li>8: 16 KB per Way. Total cache size 64 KB</li>
       </ul></td>
  </tr>
  <tr>
    <td>RISCV_ARCH</td>
    <td>64</td>
    <td><b>Architecture Size</b>. General CPU registers bit width:
       <ul>
         <li>32: RISC-V 32-bit not supproted</li>
         <li>64: RISC-V 64-bit</li>
         <li>128: RISC-V 128-bit not supported</li>
       </ul></td>
  </tr>
</table>
<b>Table 4-2. RIVER generic parameters.</b>
</center>


 @section core_rocket Rocket CPU

 Rocket is the 64-bits single issue, in-order processor developed in Berkley 
 and shared as the sources writen on SCALA language. It uses specally developed
 library \c Chisel to generate Verilog implementation from SCALA sources.
 
 Rocket Core usually implements all features of the latest ISA specification,
 either as multi-core support with L2-cache implementation and many other.
 But it has a set of disadvantages: bad integration with other devices not
 writen on SCALA, not very-good integration with RTL simulators, no reference
 model. It shows worse performance than RIVER CPU (for now).

 @section core_river River CPU

 River is my implementation of RISC-V ISA writen on VHDL either as all
 others parts of shared SoC implementation.
 There's also availabel precise SystemC model integrated into Simulator
 which is used as a stimulus during RTL simulation and garantee consistency 
 of functional and SystemC models either as RTL.

 River CPU is the 5-stage processor with the classical pipeline structure:

 <img src="../doxygen/pics/river_top.png" alt="Top Level"> 
 @latexonly {\includegraphics{../doxygen/pics/river_top.png}} @endlatexonly

*/