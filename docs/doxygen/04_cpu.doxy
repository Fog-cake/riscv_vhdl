/** @page riscv_core_page RISC-V Processor Core

  Basic tasks of Central Processor Unit (CPU) are:

\li Fetch and decode instructions
\li Supply operands for the Arithmetic and Logic unit (ALU), the Integer Multiply
and Divide block and for the Floating Pointing Unit (FPU) if enabled.
\li Load and Store data operands of the instructions

  River CPU implements five-stage pipeline with the possibility to \c Halt execution
at any time without neccessity of pipeline flushing. \c Halt signal itself can be
generated by User via Debug Support Unit (DSU) or by modules inside of pipeline.
This architecture allows to proccess several instructions in parallel and provides
functionality of the Debug Mode at any time.

  Moreover, processor River provides <b>non-invasive debugging</b> access that allows
to read/modify processors registers without halting the pipeline.

<center>
 <img src="../doxygen/pics/river_top.png" alt="Top Level"> 
 @latexonly {\includegraphics{../doxygen/pics/river_top.png}} @endlatexonly

<b>Figure 4-1. Functional diagram of the River CPU.</b>
</center>

  RISC-V Core \c River continues developing to support new instructions sets
and improve performance. The following table contains brief information
about already implemented features and features that are now in the development.

<center>
<table>
  <tr>
    <th>Function</th> <th>River, the latest ver.</th> <th>Description</th>
  </tr>
  <tr>
    <td>RISC-V User Level spec</td>  <td>2.2</td>   <td>See @link riscv.org. @endlink</td>
  </tr>
  <tr>
    <td>RISC-V Priviledged Level spec</td>  <td>1.10</td>   <td>See @link riscv.org. @endlink</td>
  </tr>
  <tr>
    <td>GCC version</td>  <td>7.2.2 or newer</td>   <td>Used as a default
       toolchain in the open-source repository</td>
  </tr>
  <tr>
    <td>GCC for Windows.</td>  <td>Yes</td>   <td>Cross-platform
        toolchain is available for a different OS</td>
  </tr>
  <tr>
    <td>C-extension</td>  <td>Yes</td>   <td>Compressed (16-bit)
        instructions set support</td>
  </tr>
  <tr>
    <td>D-extension</td>  <td>Yes</td>   <td>Double precision
       (64-bits) floating point instructions set</td>
  </tr>
  <tr>
    <td>F-extension</td>  <td>Partially</td>   <td>Single precision
       (32-bits) floating point instructions set not used in the current
        DSP algoritms. Full support will be added later or by request.</td>
  </tr>
  <tr>
    <td>A-extension</td>  <td>Planned</td>   <td>Atomic instructions
        set support. Planned in release v.11.0</td>
  </tr>
  <tr>
    <td>Instruction Cache</td>  <td>Yes</td>   <td>Configurable
       IP. Default configurations: 4-ways, 16 KB</td>
  </tr>
  <tr>
    <td>Data Cache</td>  <td>Developing</td>   <td>Configurable
       IP. Default configurations: 4-ways, 16 KB. Planned in v10.0</td>
  </tr>
  <tr>
    <td>Brach Predictor</td>  <td>Yes</td>   <td>Improve CPI
     performance index on 15 %</td>
  </tr>
  <tr>
    <td>Stack Protection</td>  <td>Yes</td>   <td>Generate
       exceptions on stack overflow or underflow events. This extension implements
       custom Control and Status Registers (CSR) in CPU.</td>
  </tr>
  <tr>
    <td>Watchdog</td>  <td>Planned</td>   <td>Generate reset signal if there's
       no CPU activity specified number of clock cycles. Planned in v10.0</td>
  </tr>
</table>
<b>Table 4-1. RIVER CPU features list.</b>
</center>


 @section riverlib_generic_section Generic Configuration

  River CPU implementation shared as IP block writen on VHDL. All source files
should be placed in \c riverlib VHDL library before compilation. The following
main generic parameters are avaiable for the user configuration.

<center>
<table>
  <tr>
    <th>Name</th>    <th>Value</th>   <th>Description</th>
  </tr>
  <tr>
    <td>async_reset</td>
    <td>FALSE</td>
    <td><b>Reset Type</b>. Internal registers reset type:
       <ul>
         <li>FALSE: syncrhonous reset (FPGA)</li>
         <li>TRUE: asynchronous reset (ASIC)</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_VENDOR_ID</td>
    <td>X"000000F1"</td>
    <td><b>Vendor ID</b>. Hardcoded constant available for reading in
       standard CSR register described in RISC-V ISA</td>
  </tr>
  <tr>
    <td>CFG_IMPLEMENTATION_ID</td>
    <td>X"20190512"</td>
    <td><b>Implementation ID</b>. Hardcoded constant available for reading in
       standard CSR register described in RISC-V ISA.</td>
  </tr>
  <tr>
    <td>CFG_HW_FPU_ENABLE</td>
    <td>true</td>
    <td><b>Enable FPU</b>. Enable/disable FPU IP:
       <ul>
         <li>FALSE: Disable FPU</li>
         <li>TRUE: Enable FPU</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_SINGLEPORT_CACHE</td>
    <td>true</td>
    <td><b>Singleport Memory in Caches</b>. Specify memory blocks type
       used in caches implementation. Dual-Port memory can improve performance
       but requires bigger ASIC silicon usage.
       <ul>
         <li>FALSE: Use Dual-Port memory blocks for caches</li>
         <li>TRUE: Use Single-Port memory blocks for caches</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_IINDEX_WIDTH</td>
    <td>6</td>
    <td><b>Lines Per Way</b>. This value defines number of lines
       instantiated in each way for Instruction Cache:
       <ul>
         <li>1: Analog of Cache disabled</li>
         <li>6: 4 KB per Way. Total cache size 16 KB</li>
         <li>7: 8 KB per Way. Total cache size 32 KB</li>
         <li>8: 16 KB per Way. Total cache size 64 KB</li>
       </ul></td>
  </tr>
  <tr>
    <td>CFG_DINDEX_WIDTH</td>
    <td>6</td>
    <td><b>Lines Per Way</b>. This value defines number of lines
       instantiated in each way for Data Cache:
       <ul>
         <li>1: Analog of Cache disabled</li>
         <li>6: 4 KB per Way. Total cache size 16 KB</li>
         <li>7: 8 KB per Way. Total cache size 32 KB</li>
         <li>8: 16 KB per Way. Total cache size 64 KB</li>
       </ul></td>
  </tr>
  <tr>
    <td>RISCV_ARCH</td>
    <td>64</td>
    <td><b>Architecture Size</b>. General CPU registers bit width:
       <ul>
         <li>32: RISC-V 32-bit not supproted</li>
         <li>64: RISC-V 64-bit</li>
         <li>128: RISC-V 128-bit not supported</li>
       </ul></td>
  </tr>
</table>
<b>Table 4-2. RIVER generic parameters.</b>
</center>


 @section cpu_prefetch_section Program Flow Control

  The Instruction Fetch Unit prefetches and preprocesses instructions to
provide a continuous instruction flow. Fetch module continuously requests 32-bits
instruction words (1-standard or 2-compressed instructions) on each clock cycle.

  If Instruction Cache module cannot return data on the next clock
cycle Fetch module generates <c>hold pipeline</c> signal.
<c>Hold pipeline</c> signal released when \c ICache module returns valid data.
In a case of enabled \cCFG_SINGLEPORT_CACHE parameter it will take 6 clock
cycles to request and save 4-clock burst transaction.

  Preprocessing of branch instructions enables the instruction flow to be predicted.
While the CPU is in the process of decoding and executing an instruction the fetcher
starts to request a new instruction at a predicted target address. Even for a
non-sequential instruction execution, Branch Predictor and Fetcher can
generally provide a continuous instruction flow.

  During the prefetch stage, the The Branch Predictor logic analyzes up to
three prefetched instructions stored in history buffer. If a branch is detected,
then the fetcher starts to request the next instructions from the instruction
cache accordingly to the predicted rules.

 @subsection cpu_predict_subsection Branch Prediction Rules

  The Branch Predictor preprocesses instructions and classifies detected branches.
Depending on the branch class, the Branch Predictor predicts the program flow
using the following rules:

<center>
<table>
  <tr>
    <th>Branch Instruction Classes</th> <th>Instructions</th> <th>Prediction Rule</th>
  </tr>
  <tr>
    <td>Unconditional Jump</td>  <td>JAL, C_J</td>   <td>The branch is always taken</td>
  </tr>
  <tr>
    <td>Return instructions</td>  <td>RET</td>   <td>The branch is always taken</td>
  </tr>
  <tr>
    <td>Conditional Branches</td>  <td>BEQ, BNE, BLT, BGE, BLTU, BGEU</td>   
        <td> Offset direction:
            \li Unconditional or backward: branch 'taken'
            \li Conditional forward: branch 'not taken'
        </td>
  </tr>
  <tr>
    <td>Relative Jump</td>  <td>JALR</td>   <td>The branch is always not taken</td>
  </tr>
  <tr>
    <td>Standard 4-bytes instruction</td>  <td>*</td>   <td>npc = pc + 4</td>
  </tr>
  <tr>
    <td>Compressed 2-bytes instruction</td>  <td>*</td>   <td>npc = pc + 2</td>
  </tr>
</table>
<b>Table 4-3. Branch Classes and Prediction Rules.</b>
</center>

 @section general_register_section General Purpose Registers

  CPU RIVER provides one bank of 32 regsiters x0, x1, ... x31, called
General Purpose Registers (GPR), which can be accessed in one CPU cycle.
Each register is a 64-bits width and can be used as a 32-bits operand
in the RV32 (W) instructions. The GPRs are the working registers
of the arithmetic and logic units and also serve as address pointers for
indirect addressing modes.

  The register bank are access via 3-port register file providing the high
access speed required for the CPU's performance. At any time there's
available 2 registers for reading and 1 for writing. Additional
Debug Port provides debuging registers access via \c DSU.

| Register | ABI Name   | Description
|:--------:|:----------:|:-----------------------------------------
| x0       | r0         | Hard-wired zero
| x1       | ra         | Return address
| x2       | sp         | Stack pointer
| x3       | gp         | Global pointer
| x4       | tp         | Thread pointer
| x5       | t0         | Temporary/alternate link register
| x6       | t1         | Temporary register 1
| x7       | t2         | Temporary register 2
| x8       | s0/fp      | Saved register 0 / frame pointer
| x9       | s1         | Saved register 1
| x10      | a0         | Function argument 0 / return value 0
| x11      | a1         | Function argument 1 / return value 1
| x12      | a2         | Function argument 2
| x13      | a3         | Function argument 3
| x14      | a4         | Function argument 4
| x15      | a5         | Function argument 5
| x16      | a6         | Function argument 6
| x17      | a7         | Function argument 7
| x18      | s2         | Saved register 2
| x19      | s3         | Saved register 3
| x20      | s4         | Saved register 4
| x21      | s5         | Saved register 5
| x22      | s6         | Saved register 6
| x23      | s7         | Saved register 7
| x24      | s8         | Saved register 8
| x25      | s9         | Saved register 9
| x26      | s10        | Saved register 10
| x27      | s11        | Saved register 11
| x28      | t3         | Temporary register 3
| x29      | t4         | Temporary register 4
| x30      | t5         | Temporary register 5
| x31      | t6         | Temporary register 6

  Register \c x0 (zero), \c x1  (return address) usage cannot be changed
by software and hardcoded on hardware level. But usage of all others
registers is specified for the compilers to provide Application
Binary Compatibility (ABI).

  Writing into register \c x0 doesn't lead to any modification and
can be interpreted as an empty operation.

 @section csr_register_section Control and Status Registers

  Special privileged instructions provides access to the internal CPU
Control and Status Registers (CSR) set. In a common case, accordingly with the
RISC-V specification, read/write/modify access rights depends of the
current processor mode. If processor tries to execute privileged access to CSR
while in lower than neccessary privileged level, then special trap is generated
with the increased rights.


*/