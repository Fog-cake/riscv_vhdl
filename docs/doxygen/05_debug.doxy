/** @page dsu_page System Debug

  River CPU doesn't implement any special Debug Modes. Processor's
architecture allows to halt pipeline at any time without performance
degradation that allows to support non-invasive debugging. This feature
used by the debugger to read CPU registers, Stack Trace buffer, CPI and etc
continuously without the execution interrupting.

  Test Access Points (TAP) provides access to a processors registers,
preipheries and a mapped memories. The latest repository version provides
the following TAPs:

\li UART TAP - debug via serial port UART Master with the default speed 115200
\li JTAG - debug via JTAG interface with the usual frequency 12 MHz
\li Ethernet with EDCL support - debug via 100 Mb Ethernet using UDP protocol
    and hardcoded MAC and IP.

  It is possible to use all these TAP devices at the same time that was 
confirmed on FPGA board with simultaneous access via UART and Ethernet.
Special debugger is a part of \c riscv_vhdl repository that is shared with
the Apache 2.0. license too.

  Additional hardware feature of the developed debugger:

\li Hardware calculation of the Clock Per Instruction (CPI) index
    for the each core independenetly.
\li System Bus loading distribution on each master for the read and
    write transactions separately.
\li Stack tracer on hardware level.
\li Hardware Breakpoints that a perfectly suited for the application 
    debug entirely placed in a ROM.
\li I/D Cache state statuses.

@section debug_dsu_section Debug Support Unit (DSU)
 
 Debug Support Unit (DSU) was developed to interact with "RIVER" CPU
 via its debug port interace. This bus provides access to all internal CPU
 registers and states and may be additionally extended by request.
 Run control functionality like 'run', 'halt', 'step' or 'breakpoints'
 imlemented using proprietary algorithms and intend to simplify integration
 with debugger application.

 Set of general registers and control registers (CSR) are described in 
 RISC-V privileged ISA specification and also available for read and write
 access via debug port.

 @note Take into account that CPU can have any number of
 platform specific CSRs that usually not entirely documented.
 
 @section dsu_regs DSU registers mapping
 DSU acts like a slave AMBA AXI4 device that is directly mapped into 
 physical memory. Default address location for our implementation 
 is 0x80020000. DSU directly transforms device offset address
 into one of regions of the debug port:
 <ul>
    <li><b>0x00000..0x08000 (Region 1):</b> CSR registers.</li>
    <li><b>0x08000..0x10000 (Region 2):</b> General set of registers.</li>
    <li><b>0x10000..0x18000 (Region 3):</b> Run control and debug support registers.</li>
    <li><b>0x18000..0x20000 (Region 4):</b> Local DSU region that doesn't access CPU debug port.</li>
 </ul>

 @par Example:
     Bus transaction at address <em>0x80023C10</em>
     will be redirected to Debug port with CSR index <em>0x782</em>.
     
 @subsection dsu_csr CSR Region (32 KB)

  Processor Control and Status Registers directly mapped into this region
of the DSU. Each CSR register is 64-bit width and mapped into address space
accordingly with its index:

<center>
      \f[CSR_OFFSET = 8*CSR_index;\f]
</center>

<center>
| Index.| Offset  | Name              
|:-----:|:--------|-------------------
| 0x001 | 0x00008 | FFLAGS            
| 0x002 | 0x00010 | FRM               
| 0x003 | 0x00018 | FCSR              
| 0xf10 | 0x07880 | MISA              
| 0xf11 | 0x07888 | MVENDORID         
| 0xf12 | 0x07890 | MARCHID           
| 0xf13 | 0x07898 | MIMPLEMENTATIONID 
| 0xf14 | 0x078A0 | MHARTID           
| 0x041 | 0x00208 | UEPC      
| 0x300 | 0x01800 | MSTATUS   
| 0x302 | 0x01810 | MEDELEG   
| 0x303 | 0x01818 | MIDELEG   
| 0x304 | 0x01820 | MIE       
| 0x305 | 0x01828 | MTVEC     
| 0x340 | 0x01A00 | MSCRATCH  
| 0x341 | 0x01A08 | MEPC    
| 0x342 | 0x01A10 | MCAUSE  
| 0x343 | 0x01A18 | MBADADDR
| 0x344 | 0x01A20 | MIP
| 0x350 | 0x01A80 | MSTACKOVR
| 0x351 | 0x01A88 | MSTACKUND
<b>Table 5-1. List of mapped CSR registers.</b>
</center>
   

 @subsection dsu_iregs General CPU Registers Region (32 KB)

 @par CPU integer registers (0x08000).

 |Offset |Bits|Type| Reset | Name | Definition 
 |:------|:--:|:--:|:-----:|:----:|---------------------------------------------|
 |0x08000| 64 | RW | 64h'0 | zero | <b>x0</b>. CPU General Integer Register hardware connected to zero.
 |0x08008| 64 | RW | 64h'0 | ra   | <b>x1</b>. Return address.
 |0x08010| 64 | RW | 64h'0 | sp   | <b>x2</b>. Stack pointer.
 |0x08018| 64 | RW | 64h'0 | gp   | <b>x3</b>. Global pointer.
 |0x08020| 64 | RW | 64h'0 | tp   | <b>x4</b>. Thread pointer.
 |0x08028| 64 | RW | 64h'0 | t0   | <b>x5</b>. Temporaries 0.
 |0x08030| 64 | RW | 64h'0 | t1   | <b>x6</b>. Temporaries 1.
 |0x08038| 64 | RW | 64h'0 | t2   | <b>x7</b>. Temporaries 2.
 |0x08040| 64 | RW | 64h'0 | s0/fp| <b>x8</b>. CPU General Integer Register 'Saved register 0/ Frame pointer'.
 |0x08048| 64 | RW | 64h'0 | s1   | <b>x9</b>. Saved register 1.
 |0x08050| 64 | RW | 64h'0 | a0   | <b>x10</b>. Function argument 0. It is also used to save return value.
 |0x08058| 64 | RW | 64h'0 | a1   | <b>x11</b>. Function argument 1.
 |0x08060| 64 | RW | 64h'0 | a2   | <b>x12</b>. Function argument 2.
 |0x08068| 64 | RW | 64h'0 | a3   | <b>x13</b>. Function argument 3.
 |0x08070| 64 | RW | 64h'0 | a4   | <b>x14</b>. Function argument 4.
 |0x08078| 64 | RW | 64h'0 | a5   | <b>x15</b>. Function argument 5.
 |0x08080| 64 | RW | 64h'0 | a6   | <b>x16</b>. Function argument 6.
 |0x08088| 64 | RW | 64h'0 | a7   | <b>x17</b>. Function argument 7.
 |0x08090| 64 | RW | 64h'0 | s2   | <b>x18</b>. Saved register 2.
 |0x08098| 64 | RW | 64h'0 | s3   | <b>x19</b>. Saved register 3.
 |0x080a0| 64 | RW | 64h'0 | s4   | <b>x20</b>. Saved register 4.
 |0x080a8| 64 | RW | 64h'0 | s5   | <b>x21</b>. Saved register 5.
 |0x080b0| 64 | RW | 64h'0 | s6   | <b>x22</b>. Saved register 6.
 |0x080b8| 64 | RW | 64h'0 | s7   | <b>x23</b>. Saved register 7.
 |0x080c0| 64 | RW | 64h'0 | s8   | <b>x24</b>. Saved register 8.
 |0x080c8| 64 | RW | 64h'0 | s9   | <b>x25</b>. Saved register 9.
 |0x080d0| 64 | RW | 64h'0 | s10  | <b>x26</b>. Saved register 10.
 |0x080d8| 64 | RW | 64h'0 | s11  | <b>x27</b>. Saved register 11.
 |0x080e0| 64 | RW | 64h'0 | t3   | <b>x28</b>. Temporaries 3.
 |0x080e8| 64 | RW | 64h'0 | t4   | <b>x29</b>. Temporaries 4.
 |0x080f0| 64 | RW | 64h'0 | t5   | <b>x30</b>. Temporaries 5.
 |0x080f8| 64 | RW | 64h'0 | t6   | <b>x31</b>. Temporaries 6.
 |0x08100| 64 | RO | 64h'0 | pc   | <b>Instruction pointer</b>. Cannot be modified because shows the latest executed instruction address
 |0x08108| 64 | RW | 64h'0 | npc  | <b>Next Instruction Pointer</b>


 @subsection dsu_control Run Control and Debug support Region (32 KB)

 @par Run control/status registers (0x10000).

 |Bits|Type| Reset | Field Name | Bits  | Description 
 |:--:|:--:|:-----:|:----------:|:-----:|:------------------------------------------------------------|
 | 44 | RW | 61h'0 | Reserved   | 63:6  | Reserved.
 | 16 | RO | 16h'0 | core_id    | 15:4  | <b>Core ID</b>.
 | 1  | RW | 1b'0  | Reserved   | 3     | Reserved.
 | 1  | RO | 1b'0  | breakpoint | 2     | <b>Breakpoint</b>. Status bit is set when CPU was halted due the EBREAK instruction.
 | 1  | WO | 1b'0  | stepping_mode | 1  | <b>Stepping mode</b>. This bit enables stepping mode if the Register 'steps' is non zero.
 | 1  | RW | 1b'0  | halt       | 0     | <b>Halt mode</b>. When this bit is set CPU pipeline is in the halted state. CPU can be halted at any time without impact on processing data.

 @par Stepping mode Steps registers (0x10008).

 |Bits|Type| Reset | Field Name | Bits  | Description 
 |:--:|:--:|:-----:|:----------:|:-----:|:------------------------------------------------------------|
 | 64 | RW | 64h'0 | steps   | 63:0  | <b>Step counter</b>. Total number of instructions that should execute CPU before halt. CPU is set into stepping using 'stepping mode' bit in Run Control register.

 @par Clock counter registers (0x10010).

 |Bits|Type| Reset | Field Name | Bits  | Description 
 |:--:|:--:|:-----:|:----------:|:-----:|:------------------------------------------------------------|
 | 64 | RW | 64h'0 | clock_cnt  | 63:0  | <b>Clock counter</b>. Clock counter is used for hardware computation of CPI rate. Clock counter isn't incrementing in Halt state.

 @par Step counter registers (0x10018).

 |Bits|Type| Reset | Field Name | Bits  | Description 
 |:--:|:--:|:-----:|:----------:|:-----:|:------------------------------------------------------------|
 | 64 | RW | 64h'0 | executed_cnt | 63:0  | <b>Step counter</b>. Total number of executed instructions. Step counter is used for hardware computation of CPI rate.

 @par Breakpoint Control registers (0x10020).

 |Bits|Type| Reset | Field Name | Bits  | Description 
 |:--:|:--:|:-----:|:----------:|:-----:|:------------------------------------------------------------|
 | 63 | RW | 63h'0 | Reserved   | 63:1  | Reserved
 | 1  | RW | 1b'0  | trap_on_break | 0     | <b>Trap On Break</b>. Generate exception 'Breakpoint' on EBRAK instruction if this bit is set or just Halt the pipeline otherwise.

 @par Add hardware breakpoint registers (0x10028).

 |Bits|Type| Reset | Field Name | Bits  | Description 
 |:--:|:--:|:-----:|:----------:|:-----:|:------------------------------------------------------------|
 | 64 | RW | 64h'0 | add_break   | 63:0  | <b>Add HW breakpoint address</b>. Add specified address into Hardware breakpoint stack. In case of matching Instruction Pointer (pc) and any HW breakpoint there's injected EBREAK instruction on hardware level.

 @par Remove hardware breakpoint registers (0x10030).

 |Bits|Type| Reset | Field Name | Bits  | Description 
 |:--:|:--:|:-----:|:----------:|:-----:|:------------------------------------------------------------|
 | 64 | RW | 64h'0 | rem_break   | 63:0  | <b>Remove HW breakpoint address</b>. Remove specified address from Hardware breakpoints stack.

 @par Breakpoint Address Fetch registers (0x10038).

 |Bits|Type| Reset | Field Name | Bits  | Description 
 |:--:|:--:|:-----:|:----------:|:-----:|:------------------------------------------------------------|
 | 64 | RW | 64h'0 | br_address_fetch | 63:0  | <b>Breakpoint fetch address</b>. Specify address that will be ignored by Fetch stage and used Breakpoint Fetch Instruction value instead. This logic is used to avoid re-writing EBREAK into memory.

 @par Breakpoint Instruction Fetch registers (0x10040).

 |Bits|Type| Reset | Field Name | Bits  | Description 
 |:--:|:--:|:-----:|:----------:|:-----:|:------------------------------------------------------------|
 | 64 | RW | 64h'0 | br_instr_fetch | 63:0  | <b>Breakpoint fetch instruction</b>. Specify instruction that should executed instead of fetched from memory in a case of matching Breapoint Address Fetch register and Instruction pointer (pc).


 @subsection dsu_local Local DSU Region (32 KB)

 @par Soft Reset registers (0x18000).

 |Bits|Type| Reset | Field Name | Bits  | Description 
 |:--:|:--:|:-----:|:----------:|:-----:|:------------------------------------------------------------|
 | 63 | RW | 63h'0 | Reserved   | 63:1  | Reserved.
 | 1  | RW | 1b'0  | soft_reset | 0     | <b>Soft Reset</b>. Status bit is set when CPU was halted due the EBREAK instruction.

 @par Miss Access counter registers (0x18008).

 |Bits|Type| Reset | Field Name | Bits  | Description 
 |:--:|:--:|:-----:|:----------:|:-----:|:------------------------------------------------------------|
 | 64 | RO | 64h'0  | miss_access_cnt | 63:0 | <b>Miss Access counter</b>. This value as an additional debugging informantion provided by AXI Controller. It is possible to enable interrupt generation in Interrupt Controller on miss-access.

 @par Miss Access Address registers (0x18010).

 |Bits|Type| Reset | Field Name | Bits  | Description 
 |:--:|:--:|:-----:|:----------:|:-----:|:------------------------------------------------------------|
 | 64 | RO | 64h'0  | miss_access_addr | 63:0 | <b>Miss Access address</b>. Address of the latest miss-accessed transaction. This information comes from AXI Controller.

 @par Bus Utilization registers (0x18040 + n*2*sizeof(uint64_t)).

 |Offset |Bits|Type| Reset | Name  | Definition 
 |:------|:--:|:--:|:-----:|:-----:|---------------------------------------------|
 |0x18040| 64 | RO | 64h'0 | w_cnt | <b>Write transactions counter for master 0</b>. Master 0 is the RIVER CPU by default.
 |0x18048| 64 | RO | 64h'0 | r_cnt | <b>Read transactions counter for master 0</b>.
 |0x18050| 64 | RO | 64h'0 | w_cnt | <b>Write transactions counter for master 1</b>. Master 1 is unused in a case of configuration with RIVER CPU.
 |0x18058| 64 | RO | 64h'0 | r_cnt | <b>Read transactions counter for master 1</b>.
 |0x18060| 64 | RO | 64h'0 | w_cnt | <b>Write transactions counter for master 2</b>. Master 2 is the GRETH by default (Ethernet Controller with master interface). 
 |0x18068| 64 | RO | 64h'0 | r_cnt | <b>Read transactions counter for master 2</b>.


*/